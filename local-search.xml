<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hexo博客文章发布</title>
    <link href="/2021/10/01/article/"/>
    <url>/2021/10/01/article/</url>
    
    <content type="html"><![CDATA[<p>任课教师    赵阳    班级         提交时间<br>任务名称    JavaAPI<br>提交要求    项目所在文件夹，命名：组号-姓名.rar</p><ol><li>   String类中的getBytes()方法的作用是(     ) <br>A.    将整数变成字符串 <br>B.    将字符串变成字符数组 <br>C.    将字符串变成字节数组 <br>D.    获取字符串中字符的个数</li><li>   对字符串”ababcdabcdefg”使用indexOf(“a”)和lastIndexOf(“a”)的运行结果是(     ) <br>A.    a1,1 <br>B.    0,6<br>C.    0,0 <br>D.    1,6   </li><li> 下面程序的运行结果是什么(    )    <br>public static void main(String[] args){  <br> String s1 = “abc”;   <br>String s2 = “xyz”; <br>show(s1,s2); <br>System.out.println(s1+”—–”+s2); <br>} <br>static void show(String s1,String s2){  <br> s1 = s2+s1+”Q”;    <br>  s2 = “W”+s1;    <br> } <br>A.    abc—–xyz <br>B.    xyzabcQ—–xyzWabc <br>C.    xyzabcQ—- xyzabcQWabc <br>D.    xyzQ—-Wabc   </li><li> 对字符串的说法正确的是(    ) <br>A.    字符串是基本数据类型 <br>B.    字符串值存储在栈内存中 <br>C.    字符串值初始化后可以被改变 <br>D.    字符串值一旦初始化就不会被改变</li><li>关于null和“”说法正确的是(  ABD  )        <br>A.    null是常量<br>B.    “”是字符串对象<br>C.    null可以调用方法 <br>D.    “”可以调用方法  </li><li> 关于String类的indexOf说法不正确的是(  CD   ) <br>A.    返回指定字符在字符串中第一次出现的索引 <br>B.    返回指定子字符串在字符串第一次出现的索引 <br>C.    返回指定字符在字符串中最后一次出现的索引 <br>D.    返回指定子字符串在此字符串最后一次出现的索引</li><li> String类charAt()方法作用是 (  A   ) <br>A.    返回指定索引处的字符 <br>B.    返回指定索引出的字符串 <br>C.    返回指定字符的索引 <br>D.    返回指定字符串的索引   </li><li> 将字符串转成字符数组的方法是(  B   ) <br>A.    toString() <br>B.    toCharArray() <br>C.    toUpperCase() <br>D.    toLowerCase()   </li><li> StringBuffer字符串缓冲区的初始容量是多少个字符(   D  ) <br>A.    10个 <br>B.    12个<br>C.    14个 <br>D.    16个</li><li> 向字符串缓冲区中追加字符串，使用的方法是(  C   )<br>A.     length() <br>B.    delete()<br>C.    append() <br>D.    toString()</li><li> 关于StringBuffer和StringBuilder说法正确的是( C )          <br>A.    StringBuffer和StringBuilder的方法不同 <br>B.    StringBuffer和StringBuilder都是线程安全的 <br>C.    StringBuffer是线程安全的，StringBuilder不是线程安全的 <br>D.    StringBuffer不是线程安全的，StringBuilder是线程安全的  </li><li> 下面哪个程序的运行结果是true(  C  ) <br>A.    System.out.println(“abc”.equals(“Abc”)); <br>B.<br>C.    System.out.println(“”.equals(null)); <br>D.    System.out.println(“abc”==”ab”+”c”); <br>E.    System.out.println(“”.equalsIgnoreCase(null));</li><li> 下面代码 ”ibelieve”.lastIndexOf(“e”) 的运行结果是(  D  ) <br>A.    2 <br>B.    5<br>C.    -1 <br>D.    7  </li><li> StringBuffer类中的append()方法描述正确的是(  AC   ) <br>A.    向缓冲区追加字符串数据 <br>B.    将缓冲区中的字符串删除 <br>C.    append()方法返回值类型是StringBuffer类型 <br>D.    append()方法返回值类型是String类型   </li><li> 能切割字符串的方法是(  C   ) <br>A.    indexOf()<br>B.    substring()<br>C.    split() <br>D.    trim() </li><li> 截取字符串的方法是(  D   ) <br>A.    replace() <br>B.    toString()<br>C.    substr()   <br>D.    substring()</li><li>关于Math.PI说法正确的是(  AB  ) <br>A.    静态常量 <br>B.    被final修饰 <br>C.    Math.PI每次运行结果不一样<br>D.    以上的说法都正确</li><li> 下面程序运行的结果是( C   )           <br>String str = “abcdefg”;  <br>str.substring(0,2);    <br>System.out.println(str);<br>A.    ab <br>B.    abc   <br>C.    abcdefg  <br>D.    出现下标越界异常    </li><li> 下面程序的运行结果是(  C  )      <br>public static void main(String[] args){ <br>StringBuffer sb = new StringBuffer(); <br>sb.append(“qq”).append(“ww”); <br>show(sb,”ss”); <br>System.out.println(sb.length()); <br> }      <br>static void show(StringBuffer sb,String str){    <br>sb.append(str); <br> } <br>A.    4<br>B.    2<br>C.    6 <br>D.    0</li><li> String类中的substring()方法描述正确的是(  AB   ) <br>A.    获取字符串中的一部分 <br>B.    返回新的字符串 <br>C.    返回新的字符串数组 <br>D.    此方法没有返回值   </li><li> 下面程序运行的结果是(  D   )    <br>String str1=”1”,str2=”2”;<pre><code> if(str1==str2)&#123;     System.out.println(&quot;ABC&quot;); &#125;else if(str1&lt;str2)&#123;     System.out.println(&quot;DEF&quot;); &#125;else&#123;     System.out.println(&quot;GHI&quot;);  &#125; </code></pre>A.    ABC<br>B.     DEF<br>C.    GHJ <br>D.    编译失败 </li><li> 关于Integer类中的静态方法parseInt()方法说法正确的是(  BC   ) <br>A.    将小数转换成整数 <br>B.    将数字格式的字符串转成整数 <br>C.    parseInt()方法永远不会抛出异常 <br>D.    将单个字符转成整数  </li><li> 将十进制数100转成二进制数用哪个方法(  A   ) <br>A.    toBinaryString() <br>B.    toHexString()<br>C.    intValue() <br>D.    toOctalString()  </li><li> String类中split()方法描述正确的是(  AC  ) <br>A.    切割字符串 <br>B.    返回一个新的字符串 <br>C.    返回一个新的字符串数组 <br>D.    此方法没有返回值</li><li>下面代码运行的结果是(  C   )              <br>Integer x = 3 ; //自动装箱   <br>x = x + 3;   //自动拆箱   <br>System.out.println(x); <br>A.    编译失败 <br>B.    x3<br>C.    6 <br>D.    Null   </li><li> System.getProperties()的作用是(  A )         <br>A.    获取当前的操作系统的属性 <br>B.    获取当前JVM的属性 <br>C.    获取指定键指示的操作系统属性 <br>D.    获取指定键指示的JVM的属性    </li><li> 下面所有描述String类中equals()方法正确的是( ABC  ) <br>A.    equals()方式是覆盖Object类中的equals()方法 <br>B.    equals()比较字符串中的内容，区分大小写 <br>C.    equals()方法的的返回值是布尔类型 <br>D.    以上说法都不正确    </li><li> 可以获取绝对值的方法是(  D  ) <br>A.    Math.ceil() <br>B.    Math.floor()<br>C.    Math.pow() <br>D.    Math.abs()</li><li> Math.random()说法正确的是( C  ) <br>A.    返回一个不确定的整数 <br>B.    返回0或是1 <br>C.    返回一个随机的double类型数，该数大于等于0.0小于1.0 <br>D.    返回一个随机的int类型数，该数大于等于0.0小于1.0   </li><li> Math.ceil(-12.5)运行结果是(   D  )      <br>A.    -13<br>B.    -11<br>C.    -12 <br>D.    -12.0   </li><li> Math.floor(15.6)运行结果是(  A  )       <br>A.    15.0<br>B.    15<br>C.    16.0 <br>D.    16.6    </li><li> 在Random类中，可以生成100以内非负整数的随机数的方法是(  C   ) <br>A.    nextDouble() <br>B.    nextFloat()<br>C.    nextInt(100) <br>D.    nextInt()</li><li> Date类中，哪个方法可以返回当前日期对象的毫秒值(  B     ) <br>A.    getSeconds()<br>B.    getTime()<br>C.    getDay() <br>D.    getDate()   </li><li> 可以获取当前日期毫秒值的方法是(  AB   ) <br>A.    Date d = new Date();  d.getTime(); <br>B.    long start = System.currentTimeMillis(); <br>C.    Calendar中的getTime(); <br>D.    DateFormat中的getTime()    </li><li> DateFormat类中的parse()方法描述正确的是(  C   ) <br>A.    将毫秒值转成日期对象 <br>B.    格式化日期对象 <br>C.    将字符串转成日期对象 <br>D.    将日期对象转成字符串   </li><li> 下面程序的运行结果是( D )     <br>String s1 = “abc”;     <br>String s2 = new String(“abc”);    <br>System.out.println(s1==s2);     <br>String s3 = “你好吗”;    <br>String s4 =”你”;    <br>String s5 =”好吗”;     <br>System.out.println(s3==(s4+s5))     <br>//s3==new  StringBuffer(s4).append(s5).toString(); <br>A.    true true <br>B.    false true<br>C.    true flase <br>D.    false false    </li><li> 下面说法正确的是(  ACD  )            <br>A.    字符串缓冲区是为了提高字符串的操作效率 <br>B.    StringBuilder是线程安全的 <br>C.    StringBuffer是线程安全的 <br>D.    String类的valueOf()方法可以将任意类型变成字符串 </li><li>编写一个程序，将下面的一段文本中的各个单词的字母顺序翻转，  “To be or not to be”，将变成”oT eb ro ton ot eb.”。</li><li>String s=”name=zhangsan age=18 classNo=090728”;  将上面的字符串拆分，结果如下:  zhangsan 18 090728</li><li>要求编写一个用户注册程序，用户注册时，需要输入个人信息，利用字符串的相关方法验证输入信息，个人信息：用户名，密码，电话，e-mail，验证规则：<br>1）用户名，密码必须输入6位及6位以上<br>2）密码，包含英文字母大小写，数字，特殊字符“@”或者“.”<br>3）电话，11位号码前三位可以是 177，176、185、181、178，其他不符合就不能注册<br>4）e-mail格式有“@”,”.”在中间位置，不可以在开头,要求“.”，必须在“@”后面。（正确的邮箱<a href="mailto:&#x73;&#111;&#x6d;&#x65;&#x6f;&#x6e;&#101;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#111;&#x6d;">&#x73;&#111;&#x6d;&#x65;&#x6f;&#x6e;&#101;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#111;&#x6d;</a>）</li></ol>]]></content>
    
    
    <categories>
      
      <category>搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/25/hello-world/"/>
    <url>/2021/09/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
